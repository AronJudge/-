

应用软件工程师需要看到一个没有硬件的纯粹的软件世界，硬件必须透明地呈现给他。谁来实现硬件对应用软件工程师的隐形？这个光荣而艰巨的任务就落在了驱动工
程师的头上。

设备驱动充当了硬件和应用软件之间的纽带，应用软件时只需要调用系统软 件的应用编程接口（API）就可让硬件去完成要求的工作。在系统没有操作系统的情况下，工
程师可以根据硬件设备的特点自行定义接口，如对串口定义 SerialSend()、SerialRecv()，对LED 定义 LightOn()、LightOff()，对 Flash 定义 
FlashWr()、FlashRd() 等。而在有操作系统的 情况下，驱动的架构则由相应的操作系统定义，
驱动工程师必须按照相应的架构设计驱动， 这样，驱动才能良好地整合入操作系统的内核中。

一般情 况下，每一种设备驱动都会定义为一个软件模块，包含 .h 文件和 .c 文件，前者定义该设备
驱动的数据结构并声明外部函数，后者进行驱动的具体实现。

其他模块想要使用这个设备的时候，只需要包含设备驱动的头文件 serial.h，然后调用其
中的外部接口函数。


操作系统通过给驱动制造麻烦来达到给上层应用提供便利的目的


计算机系统的硬件主要由 CPU、存储器和外设组成。随着 IC 制作工艺的发展，目前， 芯片的集成度越来越高，往往在 CPU 内部就集成了存储器和外设适配器

相当多的
ARM、PowerPC、MIPS 等处理器都集成了 UART、I 2 C 控制器、SPI 控制器、USB 控制器、
SDRAM 控制器等，有的处理器还集成了 GPU（图形处理器）、视频编解码器等。

Linux 将存储器和外设分为 3 个基础大类。
● 字符设备。字符设备指那些必须以串行顺序依次进行访问的设备，如触摸屏、磁带驱动器、鼠标 等。
● 块设备。块设备可以按任意顺序进行访问，以块为单位进行操作，如硬盘、eMMC 等。对于用户而言，它们都要使用文件系统的操作接 口 open()、close()、read()、write() 等进行访问。

字符设备与块设备都被映射到 Linux 文件系统的文件和目录，通过文件系统的系统调用接口 open()、write()、read()、close() 等即可访问字符设备和块设备。
Linux 的块设备有两种访问方法：一 种是类似 dd 命令对应的原始块设备，如“ /dev/sdb1”等；另外一种方法是在块设备上建立 FAT、EXT4、BTRFS 等文件系统，
然后以文件路径如“ /home/barry/hello.txt ”的形式进行访问。

● 网络设备  网络设备面向数据包的接收和发送而设计，内核与网络设备的通信与内核和字符设备、网络设备的通信方式完全不同，前 者主要还是使用套接字接口。

![Linux设备驱动](Image/img.png)

Linux 设备驱动的学习是一项浩繁的工程，包含如下重点、难点。
● 编写 Linux 设备驱动要求工程师有非常好的硬件基础，懂得 SRAM、Flash、SDRAM、
磁盘的读写方式，UART、I 2 C、USB 等设备的接口以及轮询、中断、DMA 的原理，
PCI 总线的工作方式以及 CPU 的内存管理单元（MMU）等。
● 编写 Linux 设备驱动要求工程师有非常好的 C 语言基础，能灵活地运用 C 语言的结
构体、指针、函数指针及内存动态申请和释放等。
● 编写 Linux 设备驱动要求工程师有一定的 Linux 内核基础，虽然并不要求工程师对
内核各个部分有深入的研究，但至少要明白驱动与内核的接口。尤其是对于块设
备、网络设备、Flash 设备、串口设备等复杂设备，内核定义的驱动体系结构本身就
非常复杂。
● 编写 Linux 设备驱动要求工程师有非常好的多任务并发控制和同步的基础，因为在驱
动中会大量使用自旋锁、互斥、信号量、等待队列等并发与同步机制。

## Linux 驱动的硬件基础

### 处理器

主流的通用处理器（GPP）多采用 SoC（片上系统）的芯片设计方法，集成了各种功 能模块，每一种功能都是由硬件描述语言设计程序，然后在 SoC 内由电路实现的。
每一个模块不是一个已经设计成熟的 ASIC 器件，而是利用芯片的一部分资源去实现某种传统的功能，将各种组件采用类似搭积木的方法组合在一起。

很多 ARM 主控芯片的集成度非常高，除了集成多核 ARM 以外，还可能集成图形处理器、视频编解码器、浮点协处理器、GPS、WiFi、蓝牙、基带、Camera 等一系列功能。


中央处理器的体系结构可以分为两类，一类为冯·诺依曼结构，另一类为哈佛结构

冯·诺依曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。程序指令存储地址和数据存储地址指向同一个存储器的不 同物理位置，因此程序指令和数据的宽度相同。

而哈佛结构将程序指令和数据分开存储，指令和数据可以有不同的数据宽度。哈佛结构还采用了独立的程序总线和数据总线，分别作为 CPU 与每个存储器之间的专用通信路径，具有较高的执行效率。
[CPU结构](Image/img_1.png)

从指令集的角度来讲，中央处理器 也可以分为两类，即 RISC（精简指令集计算机）和 CISC（复杂指令集计算机）。

数字信号处理器（DSP）针对通信、图像、语音和视频处理等领域的算法而设计。它包含 独立的硬件乘法器。 

DSP 的乘法指令一般在单周期内完成，且优化了卷积、数字滤波、 FFT （快速傅里叶变换）、相关矩阵运算等算法中的大量重复乘法,DSP 分为两类，一类是定点 DSP，另一类是浮点 DSP

网络处理器是一种可编程器件, 它应用于电信领域的各种任务，如包处理、协议分析、 路由查找、声音 / 数据的汇聚、防火墙、QoS 等,网络处理器器件内部通常由若干个微码处
理器和若干硬件协处理器组成，多个微码处理器在网络处理器内部并行处理，通过预先编制 微码来控制处理流程。而对于一些复杂的标准操作（如内存操作、路由表查找算法、QoS
的拥塞控制算法、流量调度算法等），则采用硬件协处理器来进一步提高处理性能，从而实现 了业务灵活性和高性能的有机结合。

对于某些应用场合，使用 ASIC（专用集成电路）往往是低成本且高性能的方案。使用 ASIC 完成同样的功能往 往比直接使用 CPU 资源或 
CPLD（复杂可编程逻辑器件）/FPGA（现场可编程门阵列）来得 更廉价且高效。

![处理器](Image/img_2.png)

复杂的系统中，这些芯片可能会 同时存在，协同合作，各自发挥自己的长处。如在一款智能手机中，可使用 MCU 处理图形
用户界面和用户的按键输入并运行多任务操作系统，使用 DSP 进行音视频编解码，而在射频 方面则采用 ASIC。

### 存储器

存储器主要可分类为只读储存器（ROM）、闪存（Flash）、随机存取存储器（RAM）、光 / 磁介质储存器。

ROM 还 可 再 细 分 为 
1. 不 可 编 程 ROM、 
2. 可 编 程 ROM（PROM）、
3. 可 擦 除 可 编 程 ROM （EPROM）
4. 电可擦除可编程 ROM（E 2 PROM），完全可以用软件来擦写，已经非常方便了。

NOR（或非）和 NAND（与非）是市场上两种主要的 Flash 闪存技术，NOR Flash 和 CPU 的接口属于典型的类 SRAM 接口（如图 2.5 所示）

![SRAM](Image/img_3.png)

Flash 的编程原理都是只能将 1 写为 0，而不能将 0 写为 1。因此在 Flash 编程之前，必 须将对应的块擦除，而擦除的过程就是把所有位都写为 1 的过程，块内的所有字节变为

0xFF。另外，Flash 还存在一个负载均衡的问题，不能老是在同一块位置进行擦除和写的动作，这样容易导致坏块。 

ROM、Flash 和磁介质存储器都属于非易失性存储器（NVM）的范畴，掉电时信息不会丢失，而 RAM 则与此相反

